<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Video Call</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f5f5f5;
      }

      .container {
        width: 100%;
        max-width: 1000px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .video-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        width: 100%;
      }

      .video-wrapper {
        width: 45%;
        min-width: 300px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      video {
        width: 100%;
        background-color: #222;
        border-radius: 8px;
      }

      .status {
        margin: 20px 0;
        padding: 10px;
        border-radius: 4px;
        background-color: #e0e0e0;
        width: 100%;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Simple Video Call</h1>
      <div class="status" id="status">Connecting...</div>

      <div class="video-container">
        <div class="video-wrapper">
          <video id="localVideo" autoplay muted playsinline></video>
          <p>You</p>
        </div>
        <div class="video-wrapper">
          <video id="remoteVideo" autoplay playsinline></video>
          <p>Remote User</p>
        </div>
      </div>
    </div>

    <script>
      // Variables
      let socket;
      let localStream;
      let peerConnection;
      let isInitiator = false;

      // DOM elements
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const statusElement = document.getElementById("status");

      // Update status message
      function updateStatus(message) {
        statusElement.textContent = message;
      }

      // Start everything when page loads
      async function init() {
        try {
          // Get camera and microphone
          localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          localVideo.srcObject = localStream;

          // Connect to server
          connectToServer();
        } catch (error) {
          updateStatus(`Camera/mic error: ${error.message}`);
        }
      }

      // Connect to WebSocket server
      function connectToServer() {
        socket = new WebSocket("ws://localhost:8000");

        socket.onopen = () => updateStatus("Waiting for another person...");
        socket.onmessage = handleMessage;
        socket.onclose = () => {
          updateStatus("Disconnected. Refresh to reconnect.");
          cleanup();
        };
      }

      // Handle incoming messages
      function handleMessage(event) {
        const data = JSON.parse(event.data);

        switch (data.type) {
          case "connection":
            isInitiator = data.id === 0;
            break;

          case "ready":
            updateStatus("Another person joined. Starting call...");
            startCall();
            break;

          case "offer":
            handleOffer(data);
            break;

          case "answer":
            peerConnection.setRemoteDescription(
              new RTCSessionDescription(data.sdp)
            );
            break;

          case "ice-candidate":
            if (peerConnection) {
              peerConnection.addIceCandidate(
                new RTCIceCandidate(data.candidate)
              );
            }
            break;

          case "disconnected":
            updateStatus("Other person left. Waiting for someone new...");
            if (peerConnection) {
              peerConnection.close();
              peerConnection = null;
              remoteVideo.srcObject = null;
            }
            break;
        }
      }

      // Start video call
      async function startCall() {
        // Create peer connection with Google's STUN servers
        peerConnection = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });

        // Add our video/audio to the connection
        localStream
          .getTracks()
          .forEach((track) => peerConnection.addTrack(track, localStream));

        // When we get the other person's stream
        peerConnection.ontrack = (event) => {
          if (event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
          }
        };

        // When we find a way to connect
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.send(
              JSON.stringify({
                type: "ice-candidate",
                candidate: event.candidate,
              })
            );
          }
        };

        // Connection state changes
        peerConnection.onconnectionstatechange = () => {
          if (peerConnection.connectionState === "connected") {
            updateStatus("Connected!");
          }
        };

        // If we're the first person, start the call
        if (isInitiator) {
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);
          socket.send(
            JSON.stringify({
              type: "offer",
              sdp: peerConnection.localDescription,
            })
          );
        }
      }

      // Handle incoming call
      async function handleOffer(data) {
        if (!peerConnection) {
          startCall();
        }

        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(data.sdp)
        );
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.send(
          JSON.stringify({
            type: "answer",
            sdp: peerConnection.localDescription,
          })
        );
      }

      // Clean up resources
      function cleanup() {
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }

        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localVideo.srcObject = null;
        }

        remoteVideo.srcObject = null;
      }

      // Handle page close
      window.onbeforeunload = () => {
        cleanup();
        if (socket) socket.close();
      };

      init();
    </script>
  </body>
</html>
